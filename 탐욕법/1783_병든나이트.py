# 병든 나이트

# 문제

# 병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

# 2칸 위로, 1칸 오른쪽 -2, +! 
# 1칸 위로, 2칸 오른쪽 -1 +2 
# 1칸 아래로, 2칸 오른쪽 +1 +2
# 2칸 아래로, 1칸 오른쪽 +2 +1 
# 병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

# 체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

# 입력
# 첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

# 출력
# 병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.


from math import ceil

n,m = map(int,input().split())
result = 0

# 세로 길이가 2라면
if n==2:
    # 세로 길이가 2라면, 절대 1,2,3,4 이동방법을 다 사용할 수 없다. (다 사용하려면 세로 길이가 최소한 3은 되어야 한다)
    # 따라서 세로 길이가 2일 때, 5번 움직일 수 있더라도, 최대 경우의 수는 4이다.
    # 5번 이상 움직일 수 없을 경우에는, 
    # 오른쪽으로 두 칸 움직이고 위,아래로 한 칸 움직이는 경우의 수만 가능하므로
    # m/2의 반올림 값이다.
    result = min(4,ceil(m/2))
        
# 세로 길이가 1일 때
elif n ==1:
    result = 1

# 세로 길이가 3 이상일 떄         
elif n>=3:
    # 가로 길이가 6 이하일 때, 경우의 수는 
    # m개의 길이 만큼(오른쪽으로 1씩) 움직일 수 있는데, 단 5번 이상일 경우 불가능 하다 
    # 5번 이상 움직이면 1,2,3,4번을 포함해서 움직여야 하는데 위 조건을 만족하려면 길이가 최소한 7은 되어야 하기 때문이다. 
    if  m < 7:
        result = min(m,4)
    else:
        result = 5+(m-7) # 1,2,3,4를 포함 = 5칸 차지, m-7개 길이 만큼 움직이기 (7개는 1,2,3,4에서 움직인 가로 길이)

print(result)


