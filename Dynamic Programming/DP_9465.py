# 링크 : https://www.acmicpc.net/problem/9465
# 풀이 : https://velog.io/@yje876/python%EB%B0%B1%EC%A4%80DP-9465-%EC%8A%A4%ED%8B%B0%EC%BB%A4

'''
단계별 최대값을 구하는 알고리즘
이렇게 숫자가 있다 가정했을 때, 
50	10	100	20	40
30	50	70	10	60

각 위, 아래 인덱스는 대각선의 값만 더할 수 있음 
분리해서 생각해보면 
50	10 
30	50
인덱스 1번 까지만 존재한다 가정,  10이 가질 수 있는 최대는 30
                                50이 가질 수 있는 최대는 50이다.
인덱스 2번 까지만 존재한다 가정,  100이 가질 수 있는 값은 (대각선 값)
                                1) 30   
                                2) 50 + 50
                                최대값은 2) 이므로 50+50을 선택 
                                70이 가질 수 있는 값은 
                                50, 10+30 중 MAX인 50이다.  
50	10+30	100	
30	50+50	70
인덱스 3번 까지만 존재한다 가정,  100이 가질 수 있는 값은 (대각선 값)
                                1) 30   
                                2) 50 + 50
                                최대값은 2) 이므로 50+50을 선택 
                                70이 가질 수 있는 값은 
                                50, 10+30 중 MAX인 50이다.  
50	10+30	100+50+50 20        20이 가질 수 있는 값 중 MAX = 70 + 50	
30	50+50	70+50	10          10이 가질 수 있는 값 중 MAX = 100+50+50 

인덱스 4번도 동일하게 반복 
50	10+30	100+50+50 20+70+50	40
30	50+50	70+50	10+100+50_50 60 

4번 반복 수행 결과

50	10+30	100+50+50 20+70+50	40+10+100+50+50
30	50+50	70+50	10+100+50+50 60+100+50+50

마지막 인덱스의 수행 내용은 모든 인덱스 값에서 가능한 선택지 중 최대값을 고려한 값
따라서 마지막 4번 인덱스에서 가장 큰 값을 선택한다. 
60+100+50+50 > 40+10+100+50+50 이므로 
최대값은 260이 된다 
    

'''
t = int(input())

for i in range(t):
    n = int(input())
    dp = [list(map(int, input().split())) for _ in range(2)]

    if n == 1:
        print(max(dp[0][0], dp[1][0]))

    else:
        dp[0][1] += dp[1][0]
        dp[1][1] += dp[0][0]

        for i in range(2,n):
            dp[0][i] += max(dp[1][i-1], dp[1][i-2])
            dp[1][i] += max(dp[0][i-1], dp[0][i-2])
        print( max(dp[0][n-1], dp[1][n-1]))

